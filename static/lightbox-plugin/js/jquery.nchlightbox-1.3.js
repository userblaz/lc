/**
 * Mousewheel plugin
 */
( function( $, ndef ){ $.fn.mousewheel = function( f ){ var o = $(this), h = [ 'DOMMouseScroll', 'mousewheel' ], vl = 'EventListener', bl, scroll = function( e ){ e = e || window.event; f( e, ( e.wheelDelta ? e.wheelDelta / 120 : e.detail / 3 ) ); e.preventDefault(); return false }; o.on( 'mouseover mouseout', function(e){ for( var i in h ) e.target[ ( e.target[ 'add' + vl ] !== ndef ) ? ( ( ( bl = ( e.type == 'mouseout' ) ) ? 'remove' : 'add' ) + vl ) : ( ( bl ? 'attach' : 'detach' ) + 'Event' ) ]( h[i], scroll, false ) }) } })( jQuery );
 
/**
 * Nacho Lightbox
 * Adaptable lightbox plugin featuring responsive grid, touch events and retina icons.
 * Include colors in images where possible using bgFFFFFF followed by a dot, a minus or an underline.
 *
 * @requires jQuery, Hammer.js
 * @author Cristian Dobre
 */
( function( $, ndef ){
	
	"use strict";

	/**
	 * Media Item options
	 */
	var defaults = {
		
		mode: 'continuous',
		
		/**
		 * Styling options, thumbs sets thumbnail alignment, use false to disable
		 */
		thumbs: 0,
		thumbsize: 100,
		
		scheme: 'dark',
		theme: 'metro',
		
		/**
		 * Default media size( used for videos )
		 */
		size: '960,540',
		
		/**
		 * Utility options
		 */
		play: true,
		autoplay: false,
		share: true,
		social: 'fb,tw,gp,pin',
		duration: 4000,
		keyboard: true,
		fullscreen: true,
		margin: 10,
		zoom: true,
		fxspeed: 250,
		
		/**
		 * Autogrid options
		 */
		grid: 0,
		gridspace: 4,
		gridorder: true,
		captions: 'title',
		
		info: false,
		
		/**
		 * Default color
		 */
		backlight: '#fff',
		usecolor: false,
		animation: 'swipe',
		
		/**
		 * Try to read an external image's color using CORS requests
		 * It will slow down the loading time for your images
		 */
		cors: false,
		hashpath: 'nch/',
		
		/**
		 * Clicking on the background will close the lightbox if true
		 */
		bgclose: false,
		notouch: false,
		
		/**
		 * Disables hashtag navigation
		 */
		nohashes: false,
		
		/**
		 * Uses tap-to-next navigation 
		 */
		tapping: true,
		
		/**
		 * Overlay color
		 */
		overlay: false
		
	},
	
	/**
	 * Lightbox instance options
	 */
	media = {
		
		title: false,
		type: false,
		rel: false,
		
		src: false,
		href: false,
		width: 0,
		height: 0,
		color: false,
		effect: false
		
	},
	
	/**
	 * Stores image routes
	 */
	routes = {},
	
	/**
	 * Main reference
	 */
	_ = {
		
		light: false,
		current: false,
		scrollbar: true,
		all: {},
		phase: true,
		css3: window.nchcss3,
		hash: '',
		isTouchDevice: false,
		
		/**
		 * Manage events
		 */
		ns: $({}),
		event: {
			trigger : function(){
				_.ns.trigger.apply( _.ns, arguments );
			},
			on : function(){
				_.ns.on.apply( _.ns, arguments );
			},
			off : function(){
				_.ns.off.apply( _.ns, arguments );
			}
		},
		
		canFS : false,
		onload: false
		
	}, 
	
	/**
	 * Animation effects
	 * Extendable through $.fn.nchlightbox( 'fx', { newEffect: {} } );
	 *
	 * @param {CSS3 Object} css3 Object generated by the internal API
	 * @param {Float} stage Animation progress ranging from -1 to 1
	 * @param {Boolean} [flag] Tells the function to animate( if defined ) or to style
	 * @param {Number} [xaxis] Can alter the swipe behaviour
	 */
	fx = {},
	
	/**
	 * Interface controller 
	 */
	ui = {
	
		/**
		 * Opening animation
		 */
		open : function( g ){
	
			g.group.main.fadeIn( 300 );

		},
			
		/**
		 * Closing animation
		 */
		close : function( g ){
			
			var t;
			
			g.main.fadeOut( 300 );
			utils.pause( false );
			
			for( var i in g.set ) if( t = g.set[ i ].thumb ) t.className = '';
		
		},
		
		/**
		 * Media slideOut effect
		 */
		slideOut : function( g, fn ){
			
			var eff = utils.getFX( g.opts.effect, g ), m = g.group, el = m.css3, c = m.blocks.preview, stage = _.phase ? -1 : 1, alter = ( eff( 0, 0, 0, 1 ) !== ndef ), left = function( x ){ return ( alter ? eff( 0, 0, 0, x ) : x ) + _.wsize };

			eff( el, stage, true );
			c.stop().animate({ scrollLeft : left( - stage * _.wsize ) },{ duration: defaults.fxspeed, complete: function(){
				
				m.blocks.media.css( 'visibility', 'hidden' );
				eff( el, 0 );
				fn();
			
			}});
			
			if( g.thumb !== ndef ) g.thumb.className = '';
		
		},
		
		/**
		 * Media slideIn effect
		 */
		slideIn : function( g, fn ){
			
			fn = ( fn === ndef ) ? function(){} : fn;
		
			var eff = utils.getFX( g.opts.effect, g ), m = g.group, el = m.css3, c = m.blocks.preview, stage = _.phase ? 1 : -1, alter = ( eff( 0, 0, 0, 1 ) !== ndef ), left = function( x ){ return ( alter ? eff( 0, 0, 0, x ) : x ) + _.wsize };
			
			eff( el, stage );
			m.blocks.media.css( 'visibility', 'visible' );
		
			/**
			 * Force CSS3 transform to apply
			 */
			( el.el.offsetHeight + 1 );
			
			eff( el, 0, true );
			
			m.blocks.media.css( 'visibility', 'visible' );
			c.stop().scrollLeft( left( - stage * _.wsize ) ).animate({ scrollLeft : left( 0 ) }, defaults.fxspeed, function(){ c.scrollLeft( left( 0 ) ) } );

		}
		
	},
	
	/**
	 * Static media type classes
	 */
	types = {
		
		youtube : {

			is : function( e ){
				var rt = e.opts.href.match( /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/ ]{11})/ );
				if( rt ){ 
					if( ! e.opts.size ) e.opts.size = e.group.opts.size;
					e.opts.videoid = rt[ 1 ];
					return true;
				}
				return false;
			},
			create : function( e ){
				return '<iframe class="nch-lb-iframe nch-video-youtube" src="//www.youtube.com/embed/' + e.opts.videoid + '?wmode=opaque" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
			},
			thumb : function( e, fn ){
				utils.loadThumb.call( e, e.opts.src = '//img.youtube.com/vi/' + e.opts.videoid + '/hqdefault.jpg', fn );
			},
			video : true

		},
		
		vimeo : {
		
			is : function( e ){
				var rt = e.opts.href.match( /(http|https):\/\/(?:www.)?(?:(vimeo).com)\/(.*)/ );
				if( rt ){
					e.opts.videoid = rt[ 3 ];
					if( ! e.opts.size ) e.opts.size = e.group.opts.size;
					return true;				
				}
				return false;
			},
			create : function( e ){
				return '<iframe class="nch-lb-iframe nch-video-vimeo" src="//player.vimeo.com/video/' + e.opts.videoid + '" width="500" height="500" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';			
			},
			thumb : function( e, fn ){
				$.getJSON( '//vimeo.com/api/v2/video/' + e.opts.videoid + '.json?callback=?', { format: 'json' }, function( r ){ utils.loadThumb.call( e, e.opts.src = r[ 0 ][ 'thumbnail_large' ], fn ) } );
			},
			video : true

		},
		
		dailymotion : {
		
			is : function( e ){
				var rt = e.opts.href.match( /^.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/ );
				if( rt !== null ) {
					if( rt[ 4 ] !== ndef ) e.opts.videoid = rt[ 4 ];
					else e.opts.videoid = rt[ 2 ];
					
					if( ! e.opts.size ) e.opts.size = e.group.opts.size;								
					return true;
				}
				return false;
			},
			create : function( e ){
				return '<iframe class="nch-lb-iframe nch-video-dailymotion" src="//www.dailymotion.com/embed/video/' + e.opts.videoid + '" width="500" height="500" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';			
			},
			thumb : function( e, fn ){
				utils.loadThumb.call( e, e.opts.src = '//www.dailymotion.com/thumbnail/video/' + e.opts.videoid + '', fn );
			},
			video : true
			
		},
		
		html : {			
			is : function( e ){ e.opts.href = e.opts.href.replace( window.location, '' ); return ( e.opts.href.charAt( 0 ) == '#' || e.opts.href.charAt( 0 ) == '.' ) },		
			create : function( e ){ return $( e.opts.href ).show().get( 0 ) }
		},
		
		ajax : {		
			is : function( e ){ return e.opts.href.search( /^https?:\/\//i ) < 0; },
			create : function( e, fn ){ $.ajax( { url: e.opts.href, success: fn } ) }	
		},
		
		iframe : {
			is : function (){ return true },
			create : function( e ){ return '<iframe class="nch-lb-iframe" src="' + e.opts.href + '" frameBorder="0"></iframe>' }
		}
	
	},
	
	/**
	 * Plugin public methods
	 */
	methods = {
		
		init: function( opts ){
			
			var a = arguments, set = $( this ), c;
			
			/**
			 * Check for direct input, supports the following formats:
			 * 
			 * ( 'image1.jpg', opts )
			 * ( [ 'image1.jpg', 'image2.jpg' ], opts )
			 * ( [ { href: 'image1.jpg', title: 'At nowhere' }, 'image2.jpg' ], opts )
			 * 
			 * All of them are opened automatically, returns the group name
			 */
			if( set.length == 0 ){
				
				/**
				 * Stop condition
				 */
				if( opts === ndef ) return set;
				
				/**
				 * Change global defaults
				 */
				if( opts.length === ndef && a.length == 1 ) $.extend( defaults, opts );
				else {
				
					/**
					 * Format the parameters and instantiate the set
					 */
					set = utils.setFrom.apply( this, [ ( opts.charAt !== ndef ) ? [ opts ] : opts, a[ 1 ] || {} ] );
					
					/**
					 * Open the collection
					 */
					if( ( a[ 1 ] || {} ).open === ndef ) methods.open.call( set );

				}
			
			} else {
				
				/**
				 * Iterate and parse the set:
				 * 
				 * ( 'img.myimage' ).nchlightbox( ) // adds the image within a new group
				 * ( 'a.nch-lightbox' ).nchlightbox( opts ) // parses the collection and groups the media
				 */
				
				opts = opts || {};
				
				/**
				 * Iterate within the jQuery object
				 */
				set.each( function( i, o ){
					
					var e = $( o ), m = e.is( 'img' ) ? e : $( 'img', e ), p;
					
					/**
					 * Parse the options
					 */
					p = $.extend( {}, media, utils.getDataProperties( e, { rel : 'rel', title : 'title', href: 'href' } ) );
					if( m.length > 0 ) p.src = m.attr( 'src' );
					
					if( e.is( 'a' ) || m.length == 0 ) m = e;
			
					/**
					 * Add into the right collection
					 */
					if( p.rel ) {
						
						if( _.all[ p.rel ] === ndef ) _.all[ p.rel ] = new utils.mediaGroup( opts, p.rel );
						
						_.all[ p.rel ].add( m, p );
					
					} else {
					
						/**
						 * Create a default group for
						 */
						var c = new utils.mediaGroup( opts );
						
						c.add( m, p );
						
						/**
						 * Add the default group
						 */
						_.all[ c.name ] = c;
						
					}
				});			
				
			}
			
			/**
			 * Show image grids
			 */
			for( var i in _.all ) utils.renderGrid( _.all[ i ] );

			return set;
			
		},
		
		/**
		 * Opens the group
		 */
		open: function( name ){
			
			var m = $( this ), k;
			
			/**
			 * Open a group by its name
			 */
			if( name !== ndef && _.all[ name ] !== ndef ) k = _.all[ name ].set[ 0 ]; 
			
			/**
			 * Open by element selection
			 */
			if( m.data( 'nch-lb-media' ) !== ndef )	k = m.data( 'nch-lb-media' );
			else if( this.jquery ){

				methods.init.apply( this, arguments );
				return methods.open.call( this );

			}
			
			/**
			 * Change page hash and trigger the open event
			 */
			if( k ){
				
				_.event.trigger( 'open', k.group );
				_.hash = '#' + defaults.hashpath + k.opts.hash;
				if( ! defaults.nohashes ) window.location.hash = _.hash;

			}
			
			_.scrollpos = _.w.scrollTop();
			_.doc.addClass( 'nch-lb-noscroll' );	

		},
		
		next : function( e ){
			
			if( ! _.current ) return ;
			
			var c = _.current, n = c.set.length, i = c.current, t = c.set[ ( ( i + 1 == n ) ? 0 : i + 1 ) ];			
			
			_.hash = '#' + defaults.hashpath + t.opts.hash;
			if( ! defaults.nohashes ) window.location.hash = _.hash;
			
			/**
			 * Stop playing if user triggered this action
			 */
			utils.pause( e === ndef );
			_.phase = true;
			
			/**
			 * Trigger the next event
			 */
			_.event.trigger( 'next', [ _.current, t ] );
			
		},
		
		previous : function(){
			
			if( ! _.current ) return ;
			
			var c = _.current, n = c.set.length, i = c.current, t = c.set[ ( ( i == 0 ) ? n - 1 : i - 1 ) ];
			
			_.hash = '#' + defaults.hashpath + t.opts.hash;
			if( ! defaults.nohashes ) window.location.hash = _.hash;
			
			utils.pause( false );
			_.phase = false;
			
			/**
			 * Trigger the prev event
			 */
			_.event.trigger( 'previous', [ _.current, t ] );
			
		},
		
		/**
		 * Closes the group
		 */
		close : function(){
			
			if( ! _.current ) return ;
			
			var c = _.current;
			
			/**
			 * Clear the hash
			 */
			_.hash = '';
			window.location.hash = "";
			if( history && history.pushState )
				history.pushState( "", document.title, window.location.pathname + window.location.search );
			
			/**
			 * Stop playing
			 */
			if( c.playing ) methods.play();
			
			/**
			 * Detach and remove media from the DOM 
			 * bug #2: Videos continue playing after closing the lightbox.
			 */
			if( utils.fs.on ) utils.fs.toggle();
			utils.detachMedia( c.set[ c.current ] );
			
			_.event.trigger( 'close', c );
			
			/**
			 * Do closing animations
			 */
			ui.close( c );
			
			_.current.paused = false;
			
			/**
			 * Mark as closed
			 */
			_.current = c.current = false;
			
			_.doc.removeClass( 'nch-lb-noscroll' );
			window.setTimeout( function(){ _.w.scrollTop( _.scrollpos ); }, 10 );

		},
		
		/**
		 * Allows extending animations
		 */
		fx : function( e, fn ){	
			
			if( fn === ndef ) $.extend( fx, e );
			else fx[ e ] = fn;
			
		},
		
		/**
		 * Allows other plugins to hook in
		 */
		access : function( name, fn ){ if( name !== ndef ) utils[ name ] = fn; return utils; },
		
		/**
		 * Add play/stop functionality
		 */
		play : function( h ){
			
			var c = _.current, o = c.opts, m = c.main, lb = c.blocks.loading, p = c.playing, d = o.duration;
			
			/**
			 * Stop if playing is disabled
			 */
			if( ! o.play ) return ;
			
			/**
			 * Stop if already playing
			 */
			if( h === ndef && p ) return p;
			
			/**
			 * Toggle class
			 */
			m.toggleClass( 'nch-lb-playing' );
			
			/**
			 * Toggle icon
			 */
			m.find( '.nch-lb-icon-play' ).html( p ? 'p' : 's' );
			
			/**
			 * Resume or pause
			 */
			if( p )	lb.stop();
			else lb.animate({ width: m.width() },{ easing: 'linear', duration: ( 1 - ( lb.width() / m.width() ) ) * d, complete: function(){ c.paused = true; methods.next() } });			
			
			/**
			 * Check if an event should be triggered
			 */
			if( h !== false ) _.event.trigger( p ? 'stop' : 'play', c );
			
			/**
			 * Toggle playing state
			 */
			return c.playing = ! p;
			
		},
		
		stop : function( ){
			
			if( _.current.playing ) methods.play( true );
			return false;
		
		},
		
		info : function( ){
		
			if( ! _.current ) return ;
			return utils.toggleInfo.apply( {}, arguments );
		
		},
		
		addEvent : function( e, fn ){
			
			_.event.on( e, fn );
			
		},
		
		removeEvent : function( e, fn ){
			
			_.event.off( e, fn );
			
		},
		
		getGroupName : function( ){
		
			var set = $( this ), none = false, m;
			
			if( set.length > 0 ) return ( ( ( m = $( set.get( 0 ) ).data( 'nch-lb-media' ) ) !== ndef ) ? m.group.name : none );
			return none;
			
		},
		
		getMediaId : function( ){
			
			var set = $( this ), none = false, m;
			
			if( set.length > 0 ) return ( ( ( m = $( set.get( 0 ) ).data( 'nch-lb-media' ) ) !== ndef ) ? m.opts.hash : none ); 
			return none;
		
		}
		
	},
	
	mask = '',
	
	utils = {
		
		toggleInfo : function( to ){
			
			var g = _.current, b = g.blocks, p = b.info.children( '.nch-lb-info-panel' );
			
			if( to !== ndef && g.about == to ) return to;	
			
			b.info[ 'fade' + ( g.about ? 'Out' : 'In' ) ]( 400 );
			
			p.append( g.info.show() );
	
			_.event.trigger( ( g.about ? 'close' : 'open' ) + '_info', [ g ] );
			
			return g.about = !g.about;
		
		},
		
		/**
		 * Selects the thumbnail
		 */
		selectThumb : function( g ){
			
			var t = g.thumb, m = g.group, b = m.blocks, sc = 0, w, $t = $( t ), $p = $t.parent(), pi = $p.prev().find( 'img' ).get( 0 ), ni = $p.next().find( 'img' ).get( 0 );
			
			if( t === ndef || ! m.opts.thumbs ) return ;
			
			for( var i in m.set ) if( w = m.set[ i ].thumb ) w.className = '';
			
			var c = t.className = 'nch-lb-thumb-s', li, gs, sp, st = 0, o = m.opts, h = ({ top: 1, bottom: 1, left: 0, right: 0 })[ o.thumbs ], q = b.bthumbs, p = b.thumbs, s = q[ h ? 'width' : 'height' ](), d = h ? 'left' : 'top', ls = 'offset' + ( h ? 'Width' : 'Height' ), a = {};
			
			sc = q[ gs = ( 'scroll' + d.substr( 0, 1 ).toUpperCase() + d.substr( 1 ) ) ]();
			sp = ( $t.position() )[ d ];
			
			var ll = sp - 4, lu = sp + ( li = t[ ls ] ) + 4;
			
			if( pi !== ndef ) ll -= pi[ ls ] + 4;
			if( ni !== ndef ) lu += ni[ ls ] + 4;
			
			if( lu - ll > s ) a[ gs ] = sp + ( t[ ls ] / 2 ) - ( s / 2 );
			else if( ll < sc ) a[ gs ] = ll;
			else if( lu - s > sc ) a[ gs ] = lu - s;
			
			q.animate( a, 200 );
		
		},
		
		/**
		 * Handles thumb scrolling
		 */
		scrollThumbs : function( e, r ){
			
			var c = _.current, o = c.opts, el, p = o.thumbs, d = { left: 'Top', top: 'Left', right: 'Top', bottom: 'Left' };
			
			/** 
			 * Make sure that everything is alright
			 */
			if( ! c || ! p ) return ;
		
			el = c.blocks.bthumbs;
			
			/**
			 * Changes scroll position
			 */
			
			el[ 'scroll' + d[ p ] ]( el[ 'scroll' + d[ p ]]() + r * 120 );
		
		},
		
		/**
		 * Adds support for touch gestures 
		 */
		swipeGesture : function( e ){
				
			if( e.gesture === ndef ) return false;
			
			/**
			 * Know for sure if touch events are supported
			 */
			if( ! _.isTouchDevice ) _.isTouchDevice = !( e.gesture.srcEvent.changedTouches === ndef );
			
			if( _.zooming || ! _.current || e.gesture === ndef ) return true;
			
			var el = $( this ), t = $( e.target ), q = e.timeStamp, x, o = t, p, c, m, d, r = false, a, g = _.wsize / 3, n = _.current, dr = 'nch-lb-dragging', u = true, tr = n.css3, eff = utils.getFX( n.set[ n.current ].opts.effect, n.set[ n.current ] ), alter = ( eff( 0, 0, 0, 1 ) !== ndef ), left = function( w ){ return ( alter ? eff( 0, 0, 0, w ) : w ) + _.wsize };
			
			function move( e ){
			
				m = e.gesture;
				
				if( ! m ) return false;
				
				d = m.deltaX;

				if( ( a = Math.abs( d ) ) > 25 || r ) {
					
					r = true;
					
					el.stop().scrollLeft( left( - d ) );
					
					/**
					 * Apply effect
					 */
					eff( tr, d / _.wsize );
					
				}
			
			}
			
			function end( e ){
				
				var sn = _.current.set.length, ci = _.current.current;
				
				if( a > g && sn > 1 && ( ( _.current.opts.mode == 'linear' ) ? ! ( ( ci == 0 && d / a > 0 ) || ( ci == ( sn - 1 ) && d / a < 0 ) ) : 1 ) ){
					
					x = ( d > 0 ) ? 0 : ( _.wsize * 2 );
					
					el.animate({ scrollLeft: left( x - _.wsize ) }, defaults.fxspeed, function(){
						
						methods[ ( d / a < 0 ) ? 'next' : 'previous' ]( true );
						
					});
					
					eff( tr, d / a, true );
				
				} else {
					
					el.stop().animate({ scrollLeft: left( 0 ) }, defaults.fxspeed );
					
					eff( tr, 0, true );
					
				}
				
				el.off( 'drag', move ).off( 'dragend', end );
				
			}

			c = e.gesture;
			
			el.on( 'drag', move ).on( 'dragend', end );
			
			return false;
			
		},
		 
		useTouch : function( el ){
			
			el.hammer({ prevent_default: true }).on( 'dragstart', utils.swipeGesture );
			
		},
		
		disableTouch : function( el ){
			
			el.hammer({ prevent_default: false }).off( 'dragStart', utils.swipeGesture );
		
		},
		
		/**
		 * Pause and resume playing
		 */
		pause : function( r ){ if( _.current.playing && ! _.current.paused ){ if( r === true || r.type == 'mouseover' ) _.current.paused = true; methods.play( false ) } },
		resume : function( r ){ if( ! _.current.playing && _.current.paused ){ methods.play( false ); _.current.paused = false } },

		/**
		 * Uses sharing plugin to generate buttons
		 */
		openShare : function( e ){
			
			if( ! _.current ) return ;
			
			var c = _.current, i = c.current, s = c.set[ i ], t;
			
			if( e.target.className == 'nch-lb-icon-share' ){
				
				if( s.share && s.share.css( 'display' ) == 'block' ){
				
					s.share.hide();
					c.main.removeClass( 'nch-lb-sharing' );
					
				} else {
					
					c.main.addClass( 'nch-lb-sharing' );

					if( ! s.share ){		
						s.share = t = $( '<div class="nch-lb-share-btns"></div>' ).appendTo( $( 'li.nch-lb-share', c.blocks.menu ) );
						utils.shareButtons( t, c.opts.social, utils.getMediaProperties( s ) );				
					}
					
					s.share.show();
			
				}
				
			} else if( s.share ){
			
				s.share.hide();		
				c.main.removeClass( 'nch-lb-sharing' );
				
			}
			
		},
		
		/**
		 * Renders image grids replacing the first thumbnail in the list
		 */
		renderGrid : function( g ){
			
			var o = g.opts, s = g.set, c, n = false, t, k = [], q, m;
			
			/**
			 * Continue only if columns are specified
			 */
			if( ! o.grid || g.hasGrid ) return ;
			g.hasGrid = true;
			
			/** 
			 * Calculate columns
			 */
			c = o.grid.split( ',' );
			for( var i in c ) c[ i ] = parseInt( c[ i ] );
			
			utils.need( g.set, utils.getThumbnail, function(){
			
				for( var i in s )
					if( s[ i ].thumb !== ndef ){
						
						/**
						 * Hide the main element
						 */
						t = s[ i ].main.hide();
						if( ! n ) n = t;
						
						/**
						 * Creates collection
						 */
						q = $( s[ i ].thumb ).clone( true ).data( 'nch-lb-media', s[ i ] ).click( methods.open ).get( 0 );
						q.title = ( s[ i ].opts.title ) ? s[ i ].opts.title : '';
						k.push( q );
					}
				
				/** 
				 * Creates the collection
				 */
				$( '<div class="nch-lb-grid"></div>' ).insertAfter( n ).append( m = $( k ) );
				m.nchgrid({ grid: c, margin: o.gridspace, order: o.gridorder, captions: o.captions });

			});
			
			
		},
		
		/**
		 * Searches for a color definition
		 */
		parseColor : function( s ){
			
			var p = ( s + '' ).split( /bg|\_|\-|\.|\&|\#/ ), l;
			
			for( var i = 0 ; i < p.length; i ++ ) 
				if( ( l = p[ i ].length ) == 6 || l == 3 )
					if( ( new RegExp( '[a-f0-9]{' + l + '}' ) ).test( p[ i ] ) )
						return '#' + p[ i ];
			
			return false;
		
		},
		
		/**
		 * Toggles zooming
		 */
		toggleZoom : function(){
			
			var c = _.current, m = c.main, l = 'nch-lb-zooming', i = c.set[ c.current ], s = i.nsize;
			
			if( m.hasClass( l ) ){
				
				_.zooming = false;			
				
				utils.updateMediaLayout( i );
				c.blocks.zoom.find( '.nch-lb-zoom-container' ).remove();
			
			} else {

				_.zooming = true;
				
				var cnt, img = new Image();
				img.onload = function(){
					
					cnt = utils.pinch.call( $( img ), '100%', '100%' ).css({ position: 'absolute' }).addClass( 'nch-lb-zoom-container' );
					c.blocks.zoom.append( cnt );
				
				}				
				img.src = i.target.src;
				
			}
			
			m.toggleClass( l );
		
		},
		
		/**
		 * Creates the media information [ title, media, url ], used for sharing
		 */
		getMediaProperties : function( i ){
			
			var o = i.opts, t = o.type, r = {
				title: o.title || document.title,			
				media: ( t != 'html' && t != 'ajax' ) ? ( ( t == 'image' || t == 'iframe' ) ? i.target.src : o.href ) : ''
			};
			
			r.url = ( ( types[ t ] && types[ t ].video ) || t == 'iframe' ) ? r.media : window.location.href;
			
			return r;
		
		},
		
		/**
		 * Detaches the current media from the DOM and prepares the group to open a new one
		 */
		detachMedia : function( i ){
			
			var c = i.group, m = c.main;
			
			/**
			 * Clear the title
			 */
			$( '.nch-lb-title', m ).each( function(){ $( this ).html( '' ) } );
			
			/**
			 * Get media out
			 */
			$( i.target ).detach();
	
		},
		
		/**
		 * Get content height at a specific width
		 */
		getInnerHeight : function( o, w ){
			
			o.css({ width: w, height: 'auto' }); var h = o.height(); o.css({ height: 'auto' }); 
			return h;
		
		},
		
		/**
		 * Get content width at a specific height
		 */
		getInnerWidth : function( o, h ){
			
			o.css({ height: h, width: 1 }); var w = o[ 0 ].scrollWidth; o.css({ width: 'auto' });
			return w;
			
		},
		
		/**
		 * Shows the media
		 */
		renderMedia : function( m ){
			
			/**
			 * Get the html content
			 */
			function html( h ){ m.html = h; m.target = $( h )[ 0 ]; load() }
			
			/**
			 * Add the object and the classes
			 */
			function load(){
				
				c.attr( 'class', 'nch-lb-media' ).addClass( 'nch-lb-media-' + o.type ).append( m.target )
				
				if( p.paused ) { methods.play( false ); methods.play( false ); p.paused = false }
				
				utils.updateMediaLayout( m );
				
			}
			
			var p = _.current, d = p.main, b = p.blocks, c = b.media, o = m.opts, t = o.type, q, v;			
			
			/**
			 * Set title
			 */
			$( '.nch-lb-title', d ).each( function(){ $( this ).html( o.title ) } );
			
			/**
			 * Reset playing bar
			 */
			b.loading.width( 0 );
			
			if( ! m.target ) {
			
				if( types[ t ] && types[ t ].video ) {
					
					m.target = q = $( types[ t ].create( m ) ).get( 0 );					
					v = function(){ load(); if( this.onload ) this.onload = function(){} };
					
					/**
					 * Use attachEvent for IE8
					 * bug #7
					 *
					 * IE8 is not firing the onload event correctly
					 */
					q.attachEvent ? ( q.attachEvent( 'onload', v ) ) : ( q.onload = v );
			
					_.root.append( q );
					
				} else if ( t == 'iframe' ){
					
					m.target = q = $( types[ t ].create( m ) ).get( 0 );
					load();
					
				} else if( t == 'html' || t == 'ajax' ){
					
					if( t == 'html' ) html( types[ t ].create( m ) );
					else types[ t ].create( m, html );
					
				}
			
			} else load();
		
		},
		
		/**
		 * Fit a filler box inside another preserving its aspect ratio
		 */
		fitInto: function( h_fill, v_fill, h_box, v_box ){
			
			var a_fill = h_fill / v_fill, a_box = h_box / v_box, width, height;
			
			if( a_box < a_fill ){
			
				width = ( h_fill < h_box ) ? h_fill : h_box;
				height = width / a_fill;
				
			} else {
				
				height = ( v_fill < v_box ) ? v_fill : v_box;
				width = height * a_fill;
			
			}
			
			return [ width, height ];
		
		},
		
		/**
		 * Updates media containers
		 */
		updateMediaLayout : function( m ){
			
			var pt = false, tt = _.current, rw, rh, b = tt.blocks, tmp, rel, p = b.preview, c = b.media, aw = tt.mspace.width, ah = tt.mspace.height, sp = aw / ah, o = m.opts, t = o.type;
			
			var ps = { top: 0, left: 0, width: 0, height: 0 }, os = m.nsize, oa;
			
			/**
			 * Stop if there's a zooming action pending
			 */
			if( _.zooming ) return true;
			
			/**
			 * Set standard sizes
			 */
			if( types[ t ] && types[ t ].video ) os = m.nsize = m.group.opts.size.split( ',' );
			
			rel = isNaN( o.width ) || isNaN( o.height );
			
			/**
			 * Handle images and videos
			 */
			if( t == 'image' || ( types[ t ] && types[ t ].video ) ){
				
				var a = os[ 0 ] / os[ 1 ];
				
				/** 
				 * Handle automatically if there's no default size
				 */
				if( o.width == 0 && o.height == 0 ) {
					
					tmp = utils.fitInto( os[ 0 ], os[ 1 ], aw, ah );
					ps.width = tmp[ 0 ];
					ps.height = tmp[ 1 ]; 

				} else if( o.height == 0 ){
					
					ps.width = ( aw < o.width ) ? aw : o.width;
					ps.height = ( ps.width / a > ah ) ? ( ( ps.width = ah * a ) / a ) : ps.width / a; 
					
				} else if( o.width == 0 ) {
					
					ps.height = ( ah < o.height ) ? ah : o.height;
					ps.width = ( ps.height * a > aw ) ? ( ( ps.height = aw / a ) * a ) : ( ps.height * a );
					
				}
				/**
				 * Fixed size
				 */
				else if( ! rel ){
				
					tmp = utils.fitInto( o.width / 1, o.height / 1, aw, ah );
					ps.width = tmp[ 0 ];
					ps.height = tmp[ 1 ];

				}
		
			}
		
			/**
			 * Handle iframes
			 */
			else if( t == 'iframe' ){
				
				if( o.width == 0 ) ps.width = aw;
				else if( ! rel ) ps.width = ( o.width > aw ) ? aw : o.width;
				
				if( o.height == 0 ) ps.height = ah;
				else if( ! rel ) ps.height = ( o.height > ah ) ? ah : o.height;				

			}
			
			/**
			 * Handle html and ajax
			 */
			else if( t == 'html' || t == 'ajax' ) {

				if( m.target ){
					
					pt = true;
					
					if( o.width > 0 ) ps.width = ( o.width > aw ) ? aw : o.width;
					if( o.height > 0 ) ps.height = ( o.height > ah ) ? ah : o.height;
				
				}

			}
			
			/**
			 * Calculate using percentages
			 */
			if( rel ){
			
				if( o.width / 1 ) ps.width = o.width / 1;
				else if( o.height / 1 ) ps.height = o.height / 1;
	
				rw = isNaN( o.width ) ? parseFloat( o.width ) / 100 * aw : 0;
				rh = isNaN( o.height ) ? parseFloat( o.height ) / 100 * ah : 0;
				
				if( rh && rw ){
					
					if( ! rh ) rh = rw / os[ 0 ] * os[ 1 ];
					if( ! rw ) rw = rh * os[ 0 ] / os[ 1 ];				
					
					tmp = utils.fitInto( rw, rh, aw, ah );
					ps.width = tmp[ 0 ];
					ps.height = tmp[ 1 ];
					
				} else if( rh ){
					
					rw = ps.width ? ps.width : ( rh * os[ 0 ] / os[ 1 ] );

				} else if( rw ){
					
					rh = ps.height ? ps.height : ( rw / os[ 0 ] * os[ 1 ] );
	
				}
				
				tmp = utils.fitInto( rw, rh, aw, ah );
				ps.width = tmp[ 0 ];
				ps.height = tmp[ 1 ];

			}
			
			/**
			 * HTML and AJAX content need some more calculations
			 */
			if( pt ){
		
				if( ! ps.width && ! ps.height ) ps.width = Math.min( aw, ah );
	
				var el = $( '<div style="display:block;position:relative;padding:1px"></div>' ).append( $( m.target ).clone() ).appendTo( _.root );

				if( ! ps.width ) ps.width = Math.min( utils.getInnerWidth( el, ps.height ), aw );
				if( ! ps.height ) ps.height = Math.min( utils.getInnerHeight( el, ps.width ), ah );

				el.remove();
				
			}
			
			ps.top = _.mposy = ( ah - ps.height ) / 2;
			ps.left = _.wsize + tt.mspace.left + ( aw - ps.width ) / 2;
			
			/**
			 * Enable zooming in
			 */
			m.group.main[ ( ( t == 'image' && ( os[ 0 ] > ps.width || os[ 1 ] > ps.height ) && tt.opts.zoom ) ? 'add' : 'remove' ) + 'Class' ]( 'nch-lb-can-zoom' );
			
			/**
			 * Set dimensions
			 */
			c.css( ps );
			
			if( t == 'iframe' || ( types[ t ] && types[ t ].video ) ){
				
				var ti = $( 'iframe.nch-lb-iframe', c );
				
				if( isNaN( ps.height ) ) ti.height( '100%' );
				else ti.height( ps.height );
				
				if( isNaN( ps.width ) ) ti.width( '100%' );
				else ti.width( ps.width ); 
				
			}
			
			/**
			 * Adds gesture functionality
			 */
			if( ! defaults.notouch ){
				if( t == 'html' || t == 'ajax' ){
					if( tt.hasGestures ){ 
						utils.disableTouch( b.preview );
						tt.hasGestures = false;
					}
				} else if( ! tt.hasGestures ){
					utils.useTouch( b.preview );
					tt.hasGestures = true;	
				}
			}
			
		},

		/**
		 * Retrieves the media color
		 */
		getMediaColor : function( m, fn ){
			
			var o = m.opts;
			
			/**
			 * Return the default color if required
			 */
			if( defaults.usecolor ) return fn( defaults.backlight );
			
			/**
			 * Check if color exists
			 */
			if( o.color ) return fn( o.color );
			
			/**
			 * Get image color
			 */
			if( o.type == 'image' && _.hasCanvas ) { 
				
				utils.getMainColor( m.target, function( c ){
					
					fn( 'rgb(' + c.join( ',' ) + ')' );
					
				});
				
			} else fn( defaults.backlight );
			
		},
		
		/**
		 * Count the thumbnails, if more than one, let the images render
		 */
		enoughThumbs: function( group ){
			
			var cnum = 0;
			for( var i = 0 ; i < group.set.length ; i ++ )
				group.set[ i ].opts.src && ( cnum++ );
			
			
			if( cnum > 1 ) return true;

			group.opts.thumbs = false;			
			return false;
			
		},
		
		/**
		 * Opens the collection and the media
		 */
		toMedia : function( i ){
			
			var b, now, wait = false, sel = false;
			
			methods.open.call( i );
			
			/**
			 * Disable previous loading callbacks
			 */
			if( _.onload ){
				_.onload.onload = function(){};
				_.onload = false;			
			}
			
			utils.enoughThumbs( i.group );
			
			/**
			 * Do phase adjustments
			 */
			if( _.current && _.current == i.group && ( sel = _.current.current ) !== false )
				_.phase = ( ( ! sel || ! i.index ) && ( sel + i.index == i.group.set.length - 1 ) ) ? ( sel > i.index ) : ( sel < i.index );

			/**
			 * Select the thumbnail
			 */
			if( i.group.main ) utils.selectThumb( i );	
			
			/**
			 * Waiter function
			 */
			function ops(){
			
				if( i.group.main ) i.group.blocks.media.css({ width: 0, height: 0 });		
			
				/**
				 * Render if neccesary
				 */
				if( i.group.main == false ){
				
					utils.renderLayout( i.group );
					utils.selectThumb( i );
					
				}
				
				/**
				 * Do animation effects
				 */
				if( _.current !== i.group ){
					
					if( _.current ) ui.close( _.current.group );
					
					_.current = i.group;
					_.current.current = i.index;
					
					ui.open( i );

				} else sel = i.group.current;
			
				/**
				 * Trigger an update
				 */
				utils.updateLayout();
				
				/**
				 * Continue or wait if the media isn't loaded
				 */
				if( wait === false ) wait = true;
				else if( wait !== true ) wait();
				
			}
			
			if( _.zooming ) utils.toggleZoom();
			if( ! _.current ) ops();
			else ui.slideOut( ( now = _.current.set[ _.current.current ] ), function(){
				
				utils.detachMedia( now );	
				ops();
				
			});		
			
			/**
			 * Media loaded
			 */
			function gotMediaType( t ){
				
				i.opts.type = t;
				_.onload = false;
				
				/**
				 * Render the media object
				 */
				utils.renderMedia( i );
				utils.updateMediaLayout( i );
				
				/**
				 * Do slideIn animations
				 */
				ui.slideIn( i, function(){} );
				
				/**
				 * Get and use media color
				 */
				utils.getMediaColor( i, function( c ){
					
					/**
					 * Save the color
					 */
					i.opts.color = c;
					
					/**
					 * Callback function
					 */
					function color(){ utils.light( i.opts.color ) };
					
					if( _.light === false ) _.event.on( 'maskload', color );
					else color();
				
				});
				
				/**
				 * Change indexes
				 * bug #1: Indexing issue prevented detaching, leading to
				 * multiple media items in the container
				 */
				_.current.current = i.index;				
				
			}
			
			/**
			 * Detect media type
			 */
			utils.getMediaType( i, function( t ){
				
				var fn = function() {
					if( _.current != false ){
						/**
						 * Bug #9: Prevent random loading images from appearing in the display container
						 * Detach attached media when an older, slow loading images is ready
						 */ 
						utils.detachMedia( _.current.set[ _.current.current ] );
					}
					gotMediaType( t );
				};
				
				if( wait === true ) fn();
				else wait = fn;
			
			});	

		},
		
		/**
		 * Creates the layout structure from the group reference
		 */
		renderLayout : function( g ){
			
			/**
			 * Creates the main element
			 */
			var m = g.main = $( '<div class="nch-lb-main"></div>' ).appendTo( _.b ), ap, o = g.opts, f = '', bl = {};
			
			/**
			 * Adds a theme and scheme classes
			 */
			g.main.addClass( 'nch-lb-scheme-' + o.scheme );
			if( defaults.backlight == '' ) g.main.addClass( 'nch-lb-no-backlight' );
			
			/**
			 * Check for overlay overwrite
			 */
			if( o.overlay != '' && o.overlay != false ){ g.main.css( 'background', o.overlay ); }
			
			/**
			 * Add loading icon
			 */
			var ng = bl.loadicon = $( '<div class="nch-lb-media-loading"></div>' ).appendTo( m );
			
			/**
			 * Adds specific classes
			 */
			if( _.canFS && o.fullscreen ) f += 'nch-lb-can-fs ';
			if( o.share ) f += 'nch-lb-can-share ';
			if( o.play && g.set.length > 1 ) f += 'nch-lb-can-play ';
			if( o.zoom ) f += 'nch-lb-can-zoom ';
			if( o.info ) f += 'nch-lb-has-info ';
			if( ! _.scrollbar ) f += 'nch-lb-no-scrollbar ';
			m.addClass( f );
			
			/**
			 * Used for positioning
			 */
			var d = { v : 'vertical', h : 'horizontal' }, p = { left: 'v', right: 'v', top: 'h', bottom: 'h' }, s = { v : 'width', h : 'height' }, v = { v : 'h', h : 'v' };
			
			/**
			 * Add PNGfix container, and set the transition
			 * See bug #4
			 */
			if( _.asb ){
			
				var sb = bl.asb = $( '<div class="nch-lb-pngfix"></div>' ).appendTo( m );
				utils.css3( sb ).transition( 'background-color 500ms linear' );
			
			}
			
			/**
			 * Add information about the gallery
			 */
			if( o.info )
				g.info = ( ( ap = $( '#' + o.info ) ).length ) ? ap : $( '<div></div>' );				
			
			/**
			 * Create the topbar
			 */
			var bb = bl.tbar = $( '<div class="nch-lb-tbar"></div>' ).appendTo( m ), btc = $( '<ul class="nch-lb-tbar-controls"></ul>' ); 
			
			/**
			 * Create the bottom bar, holds the controls
			 */ 
			var bt = bl.bbar = $( '<div class="nch-lb-bar"></div>' ).appendTo( m );
			
			/**
			 * Create controls
			 */
			var st, ct = bl.controls = $( '<ul class="nch-lb-controls"></ul>' ).appendTo( bt ), cti = { prev: 'left', play: 'play', next: 'right', title: false, exit: 'exit', fs: 'fs', info: 'info' }, ctif = { prev: '<', play: 'p', next: '>', title: '', exit: 'x', fs: 'f', info: 'i' };

			/**
			 * Create buttons
			 */			
			if( g.set.length == 1 ) m.addClass( 'nch-lb-no-more' );			
			for( var i in cti ) {
				ct.append( st = '<li class="nch-lb-' + i + '">' + ( cti[ i ] ? '<div class="nch-lb-icon-' + cti[ i ] + '">' + ctif[ i ] + '</div>' : '' ) + '</li>' );
				if( i == 'exit' || i == 'title' || i == 'info' || i == 'fs' ) btc.append( st );
			}
			
			/**
			 * Add thumbnail column
			 */
			if( o.thumbs ) {
				
				var l = bl.thumbs = $( '<ul class="nch-lb-thumbs"></ul>' ), t = bl.bthumbs = $( '<div class="nch-lb-thumbs-bar"></div>' ).append( l );
				
				/**
				 * Set column size and add classes
				 */
				t.addClass( 'nch-lb-thumbs-' + o.thumbs ).css( o.thumbs, 0 );
				l.addClass( 'nch-lb-thumbs-' + d[ p[ o.thumbs ] ] ).css( s[ p[ o.thumbs ] ], o.thumbsize );
				
				if( o.thumbs == 'bottom' ) bt.append( t );
				else if( o.thumbs == 'top' ) bb.append( t );
				else m.append( t );
				
				/**
				 * Arrange the controls
				 */
				if( p[ o.thumbs ] == 'v' ){
					var dcs = { left: 'auto', right: 'auto' }; 
					dcs[ ( o.thumbs == 'left' ) ? 'right' : 'left' ] = t[ s[ p[ o.thumbs ] ] ]();
					bb.css( dcs );
					bt.css( dcs );
				}

			}
			
			/**
			 * Append icons to the topbar
			 */
			btc.appendTo( bb );
			
			/**
			 * Add preview space and scroller
			 */
			var ds = bl.preview = $( '<div class="nch-lb-media-space"></div>' ).appendTo( m ), md;
			var sr = bl.scroller = $( '<div class="nch-lb-media-scroller"></div>' ).appendTo( ds ).append( md = bl.media = $( '<div class="nch-lb-media"></div>' ) );
			
			g.css3 = utils.css3( md );
			
			/**
			 * Add photo options
			 */
			var po = bl.menu = $( '<ul class="nch-lb-photo-menu"></ul>' ).appendTo( md ), pop = [ 'zoom', 'share' ], popf = [ '+', 'h' ];
			for( var i = 0; i < pop.length; i++ ) po.append( '<li class="nch-lb-' + pop[ i ] + '"><div class="nch-lb-icon-' + pop[ i ] + '">' + popf[ i ] + '</li>' );
			
			/**
			 * Add info panel
			 */
			var np = bl.info = $( '<div class="nch-lb-project"><div class="nch-lb-info-panel"><div class="nch-lb-icon-info">i</div></div></div>' ).appendTo( m );
			
			/**
			 * Add loadingbar
			 */
			var lr = bl.loading = $( '<div class="nch-lb-loadbar"></div>' ).appendTo( m );
			md.on( 'mouseover', utils.pause ).on( 'mouseout', utils.resume );

			/**
			 * Reference the elements
			 */
			g.blocks = bl;
			
			/**
			 * Load thumbnails if neccesary
			 */
			if( o.thumbs ) utils.need( g.set, utils.getThumbnail, function(){ utils.renderThumbnails( g ) } );
			
			/**
			 * Add zoom element
			 */
			var zm = bl.zoom = $( '<div class="nch-lb-zoom-space"><div class="nch-lb-icon-zoom">-</div></div>' ).appendTo( m );

			/**
			 * Add functionality
			 */
			if( o.autoplay ){ g.playing = true; g.paused = true; m.addClass( 'nch-lb-playing' ) }
			 
			$( 'div.nch-lb-icon-fs', m ).each( function(){ $( this ).click( utils.fs.toggle ) });
			$( 'li.nch-lb-exit', m ).each( function(){ $( this ).click( methods.close ) });
			
			$( 'li.nch-lb-prev', ct ).click( methods.previous );
			$( 'li.nch-lb-next', ct ).click( methods.next );
			$( 'li.nch-lb-play', ct ).click( methods.play );
			
			$( 'div.nch-lb-icon-info', m ).each( function(){ $( this ).click( utils.toggleInfo ) } );

			$( 'div.nch-lb-icon-zoom', m ).hammer().on( 'tap', utils.toggleZoom );			
			m.hammer().on( 'tap', utils.openShare );
			
			/**
			 * Close on background click
			 */
			if( o.bgclose ) utils.backgroundClose( bl );
			
			/**
			 * Tap for next media
			 */
			if( defaults.tapping )
				bl.media.on( 'tap', function( e ){
					
					if( ! _.current ) return ;
					
					var t = $( e.target );
					
					if( t.is( 'img' ) && t.parent().hasClass( 'nch-lb-media' ) ) methods.next();
					
				});
			
			
		},
		
		/**
		 * Background closing
		 */
		backgroundClose: function( bl ){
		
			bl.preview.click( function( e ){
				
				if( e.target.className.search( 'nch-lb-media-space' ) >= 0 ) methods.close();
			
			});

		},
		
		/**
		 * Fullscreen API
		 */
		fs : {

			on : false,
			
			/**
			 * Requests fullscreen on the element
			 */
			request : function( el ) {
				
				utils.fs.on = true;
				
				if ( el.requestFullScreen )	return el.requestFullScreen();
				else if ( el.requestFullscreen ) return el.requestFullscreen();
				else if ( el.webkitRequestFullScreen ){
					if( el.webkitRequestFullScreen.length == 1 ) return el.webkitRequestFullScreen();
					else return el.webkitRequestFullScreen( Element.ALLOW_KEYBOARD_INPUT );
				}
				else if ( el.mozRequestFullScreen ) return el.mozRequestFullScreen();
				
				return utils.fs.on = false;
			
			},
			
			/**
			 * Checks if browser supports fullscreen
			 */
			has : function(){	
				var t = utils.fs.request( document.documentElement );
				return ( t != false )
			},
			
			/**
			 * Exit fullscreesn state
			 */
			exit : function() {
			   
				var el = document;
				
				if ( el.cancelFullScreen ) el.cancelFullScreen();
				else if ( el.exitFullscreen ) el.exitFullscreen();
				else if ( el.webkitCancelFullScreen ) el.webkitCancelFullScreen();
				else if ( el.mozCancelFullScreen ) el.mozCancelFullScreen();
				
				utils.fs.on = false;
				
			},
			
			/**
			 * Enter fullscreen state
			 */
			toggle: function(){
				
				var c = 'nch-lb-onfs', b = _.current.main, o = b.find( '.nch-lb-icon-fs' );
				
				if( utils.fs.on ){ b.removeClass( c ); utils.fs.exit(); o.html( 'f' ); }
				else { b.addClass( c ); utils.fs.request( document.documentElement ); o.html( 'k' ); };
				
			}

		},		
		
		/**
		 * Loads the thumbnail
		 */
		loadThumb : function( src, fn ){
			
			var i;
			this.thumb = i = new Image();
			i.onload = fn;
			i.src = src;
			
		},
		
		/**
		 * Updates layout when window is resized
		 */
		updateLayout : function( resized ){
			
			var c = _.current, vw = _.wsize = _.w.width(), vh = _.hsize = _.w.height();
			
			/**
			 * Stop if the lightbox is closed
			 */
			if( ! c ) return ;
			
			var si, b = c.blocks, pv = b.preview, o = c.opts, m = o.margin, s = [ m, m, m, m ], m = c.main, t = b.bthumbs, dr = { top: 0, right: 1, bottom: 2, left: 3 }, h = 'height', w = 'width', dm = [ h, w, h, w ];
			
			/**
			 * Add the size of the thumbnails
			 */
			if( t !== ndef && o.thumbs != 'bottom' && o.thumbs != 'top' ) s[ dr[ o.thumbs ] ] += t[ dm[ dr[ o.thumbs ] ] ]();
			
			/**
			 * Add controls size
			 */
			s[ 0 ] += b.tbar.height();
			s[ 2 ] += b.bbar.height();
			
			/**
			 * Calculate available width
			 */
			si = {
			
				top: s[ 0 ],
				left: s[ 3 ],
				width: vw - s[ 1 ] - s[ 3 ],
				height: vh - s[ 0 ] - s[ 2 ]
				
			};
	
			b.bbar.width( si.width + ( 2 * o.margin ) );
			b.tbar.width( si.width + ( 2 * o.margin ) )
			
			pv.css( $.extend( {}, si, { 
				
				left: 0,
				width: vw,
				height: si.height + 40
				
			}));
			
			b.loadicon.css({ left: si.left + ( si.width / 2 ), top: si.top + ( si.height / 2 ) })
			
			/**
			 * Make it available for updateMediaLayout function 
			 */
			c.mspace = si;
			
			/**
			 * Move canvases to the main element
			 */
			function im(){
				
				if( _.asb ) return ;
				
				m.append( _.light[ 0 ].$el.height( s[ 2 ] + 100 ), _.light[ 1 ].$el.height( s[ 2 ] + 100 ) );
				
			};	
			
			if( _.hasCanvas ){
			
				if( ! _.light ) _.event.on( 'maskload', im );
				else im();
			
			}
			
			/**
			 * Update layout
			 */
			if( c.set[ c.current ].opts.type != false && c.set[ c.current ].target ) utils.updateMediaLayout( c.set[ c.current ] );
			
			
			/**
			 * Modify scroll only for resize events
			 * bug #6
			 *
			 * updateMediaLayout was altering scrollLeft values, causing blinking images
			 */
			if( resized !== ndef ) pv.scrollLeft( _.wsize );
			
		},
		
		/**
		 * Changes the colors
		 */
		light : function( s, c ){
			
			if( ! _.hasCanvas ) return ;
			
			/**
			 * Use a CSS transition of the bgColor instead of a canvas
			 * See bug #4
			 */
			if( _.asb && _.current ) {
				
				var easb = _.current.blocks.asb.get( 0 );				
				easb.style.backgroundColor = s;
				
				return ; 
			}
			
			var a = arguments, v = { opacity: 1, display: 'block' }, h = { opacity: 0 }, cc = _.light[ 0 ], ce = _.light[ 1 ];

			/**
			 * Append to the new parent
			 */
			if( a.length == 2 ) s.main.append( cc.$el, ce.canvas );
			else c = s;
			
			var s = [ 0, 0, ce.width, ce.height ], x;
			
			/**
			 * Hide the current canvas
			 */
			ce.$el.stop().animate( h, 500, function(){ 
				
				utils.toColor( ce, c );
				ce.$el.css( v );
				cc.$el.hide();

			});
			
			/**
			 * Color the hidden canvas and show it
			 */
			utils.toColor( cc, c );
			cc.$el.stop().show().css( h ).animate( v, 500 );
			
		},
		
		/**
		 * Lightens ana masks a canvas with a color
		 */
		toColor : function( o, c ){
			
			var w = o.width, h = o.height, x = o.context;
			
			x.clearRect( 0, 0, w, h );
			x.fillStyle = c;
			x.fillRect( 0, 0, w, h );
			o.mask();
		
		},
		
		/**
		 * Initializex the canvases
		 */
		masks : function(){
			
			var i = this, p = $( 'div.nch-lb-mask' ), cc = $( '<canvas class="nch-lb-effcurrent"></canvas>' ), ce = $( '<canvas class="nch-lb-effchange"></canvas>' );
			
			_.color = '#000';
			_.light = _.asb ? [ ] : [ 
				new utils.canvasMask( cc, i ),
				new utils.canvasMask( ce, i )			
			];
			
			_.event.trigger( 'maskload' );
			
		},
		
		/**
		 * Retrieves the background-image url
		 */
		getImageURL : function( e ){
			
			var b = /^url\((['"]?)(.*)\1\)$/.exec( e.css( 'background-image' ) );
			return b ? b[ 2 ] : '';
		
		},
		
		/**
		 * Watch for hash changes
		 */
		hashChange : function(){
			
			var h = '';
			window.setInterval( function(){
				if( defaults.nohashes && ( _.hash != h ) && ( h = _.hash ).search( '#' + defaults.hashpath ) == 0 ) utils.route( h.replace( '#', '' ) );
				if( ( h != window.location.hash && ( h = _.hash = window.location.hash ).search( '#' + defaults.hashpath ) == 0 ) )
					utils.route( h.replace( '#', '' ) )
			}, 150 );

		},
		
		/**
		 * Route the hashes to the coresponding objects
		 */
		route : function( s, c ){
			
			/**
			 * Stop if route doesn't match
			 */
			if( routes[ s ] === ndef ) return ;
			
			var o = routes[ s ];

			/**
			 * Opens mediaItem and its group
			 */
			utils.toMedia( o.call != ndef ? o() : o );
		
		},
		
		/**
		 * Allow external scripts to use their own routing system
		 */
		addRoute : function( hash, value ){ routes[ 'nch_' + hash ] = value }, 
		
		/**
		 * Tests if the element is an image
		 */
		isImage : function( e, fn, rr ){
			
			/**
			 * Create a new image
			 */
			var i = new Image(), cl = function(){ fn( 'image' ); };
			
			i.onerror = rr || function(){ utils.getMediaType( e, fn, true ) }
			i.onload = function(){
				
				e.target = this;
				e.nsize = [ this.width, this.height ];

				if( rr === ndef && ! utils.allowedOrigin( this ) && defaults.cors ) utils.isImage( e, fn, cl );
				else fn( 'image' );
				
			};
			
			if( rr !== ndef ) i.crossOrigin = 'anonymous';
			i.src = e.opts.href;
			_.onload = i;
			
		},
		
		/**
		 * Get the media type firing the callback
		 */
		getMediaType : function( e, fn, i ){
			
			var o = e.opts;
			
			/**
			 * Check if type was already established
			 */
			if( o.type != false ){
				
				if( ! e.target )					
					if( types[ o.type ] && types[ o.type ].video )						
						if( o.videoid === ndef ) 
							types[ o.type ].is( e );
				
				return fn( o.type );
				
			}
			
			if( i ) {
			
				for( var i in types )
					if( types[ i ].is( e ) )
						return fn( i );	
			
			} else utils.isImage.apply( this, arguments );
			
		},
		
		/**
		 * Calls respective function with each variable in set,
		 * and fire the callback when all have returned.
		 */
		need : function( set, fn, c ){
			
			var t = set.length - 1, p = 0, r = function(){ if( p ++ == t ) c() };			
			for( var i = 0 ; i <= t; i ++ ) fn( set[ i ], r );
		
		},
		
		/**
		 * Retrieves the thumbnail
		 */ 
		getThumbnail : function( e, fn ){
			
			var i = new Image(), o = e.opts, t = o.type, c = function(){ fn( e ) };
			
			/**
			 * If thumbnail was processed before
			 */
			if( e.thumb !== ndef ) return fn( e );
			
			/**
			 * If got a src, do the thumbnail
			 */
			if( o.src ){
			
				i.onload = c;
				i.src = o.src;
				e.thumb = i;
			
			} else if( types[ t ] && types[ t ].video ){
				
				/**
				 * Get the video thumbnail
				 */
				if( e.opts.videoid === ndef ) types[ t ].is( e );
				types[ t ].thumb( e, c );
				
			} else fn( e );
			
		},
		
		/**
		 * Render the thumbs into the list
		 */
		renderThumbnails : function( g ){

			var m = g.main, o = g.opts, b = g.blocks, l = b.thumbs.empty(), pe, a, cm = 0, p = { bottom: 1, top: 1, left: 0, right: 0 }, inv;
			
			l[ p[ g.opts.thumbs ] ? 'height' : 'width' ]( g.opts.thumbsize );			
			
			/**
			 * bug #3: Can't scroll thumbnails in Chrome for Android 
			 * Wrap inside a setTimeout, to avoid caching issues
			 * http://irama.org/news/2011/06/05/cached-images-have-no-width-or-height-in-webkit-e-g-chrome-or-safari/
			 */
			window.setTimeout( function(){
			
				for( var i in g.set ) 
					if( ( pe = g.set[ i ].thumb ) !== ndef ){
						a = ( pe.naturalWidth || pe.width ) / ( pe.naturalHeight || pe.height );
						cm += o.thumbsize * ( p[ g.opts.thumbs ] ? a : 1 / a ) + 8;
						l.append( $( '<li></li>' ).append( $( g.set[ i ].thumb ).removeAttr( 'width', 'height' ).data( 'nch-lb-media', g.set[ i ] ).click( methods.open ) ) );	
					}
				
				/**
				 * Set thumbnail list size
				 */
				l[ p[ g.opts.thumbs ] ? 'width' : 'height' ]( cm - 6 );
			
			}, 25 );
			
			
			/**
			 * Allow touch devices to scroll over clickable elements
			 */
			l.hammer({ prevent_default: false }).on( 'drag', function( e ){ return true } );
			
			/**
			 * Adds mousewheel support
			 */
			l.mousewheel( utils.scrollThumbs );
			
		},
		
		/**
		 * Returns the effect transition to be applied
		 */
		getFX : function( eff, media ){
			
			if( eff === false ) media.opts.effect = eff = media.group.opts.animation;
	
			if( eff == 'random' ) {
				
				var f = [];			
				
				for( var i in fx ) f.push( i );					
				media.opts.effect = media.opts.animation = eff = f[ Math.round( Math.random() * ( f.length - 1 ) ) ];
				
			}
			
			return fx[ eff ] || function(){};
		
		},
		
		/**
		 * Create a new media group for the lightbox to work with
		 */
		mediaGroup : function( opts, name ){
			
			var n, o, ns = this, c;
			
			/**
			 * Make sure the group has a name
			 */
			if( ! name ) name = utils.randomName();
			
			/**
			 * Group options
			 */
			this.main = false;
			this.name = n = name;
			this.opts = o = $.extend( {}, defaults, opts );
			this.current = false; 
			this.set = [];
			this.playing = false;
			this.paused = false;
			this.about = false;
			this.hasGestures = false;
			
			
			/**
			 * Add media element function
			 */
			this.add = function( e, p ){

				var t = new utils.mediaItem( e, utils.inheritProps( o, p ) );		
				t.group = ns;
				t.opts.rel = n;
				t.index = ns.set.length;
		
				if( ! t.opts.href ) t.opts.href = t.opts.src;			
				
				/**
				 * Parse color from filename or thumbname
				 */
				if( c = utils.parseColor( t.opts.href + t.opts.src ) ) t.opts.color = c;
				
				routes[ defaults.hashpath + t.opts.hash ] = t;
				ns.set.push( t );

			}
			
		},
		
		/**
		 * Tests for crossOrigin tainted canvas
		 */
		allowedOrigin : function( i ){
			
			if( ! _.hasCanvas ) return true;
			
			var c = _.tcanvas, x = c.getContext( '2d' ), w = c.width, h = c.height;
			
			x.clearRect( 0, 0, w, h );
			x.drawImage( i, 0, 0 );
			
			try { x.getImageData( 0, 0, 1, 1 ); }
			catch( e ){
				$( _.tcanvas ).remove();
				$( _.tcanvas = document.createElement( 'canvas' ) ).addClass( 'nch-lb-testcanvas' ).appendTo( _.b );
				return false;
			}
			
			return true;
 			
		},
		
		/**
		 * Inherits existing properties from the second object into the first
		 */
		inheritProps : function( o, c ){
			
			for( var i in o )
				if( c[ i ] !== ndef )
					o[ i ] = c[ i ];
			
			return c;
			
		},
		
		/**
		 * Creates a new media item from the given object
		 */
		mediaItem : function( e, p ){
			
			var o;
			
			this.main = e;
			this.opts = o = $.extend( { hash: utils.getHash( p ) }, media, p );
			this.target = false;
			this.share = false;
			
			e.data( 'nch-lb-media', this );
			
			e.click( function ( e ){
				
				e.preventDefault();
				methods.open.call( this );
				
				return false;
				
			});
		
		},
		
		/**
		 * Keyboard functions
		 */
		keyboard : function( e ){
			
			var k = e.which, c = _.current;		
			
			if( c && c.opts.keyboard ){
				
				if( k == 32 && c.opts.play ) methods.play();
				if( k == 37 ) methods.previous( true );
				if( k == 39 ) methods.next( true );	
				if( k == 27 ) methods.close();
			
			}
		
		},
		
		/**
		 * Allows dynamic usage
		 */
		setFrom : function( a, b ){
			
			var r = $(), c = new utils.mediaGroup( b ), t;
			
			for( var i in a ){
				
				/**
				 * Transform into objects
				 */
				if( a[ i ].charAt !== ndef ) a[ i ] = { href: a[ i ] };
				
				/**
				 * Create and insert the media
				 */
				t = $( '<a href="' + a[ i ].href + '"></a>' );
				
				/**
				 * Add small image if neccesary
				 */
				if( a[ i ].src ) t.append( '<img src="' + a[ i ].src + '">' );
				
				c.add( t, a[ i ] );
				r = r.add( t );
				
			}
			
			/**
			 * Reference the group
			 */
			_.all[ c.name ] = c;
			
			return r;
			
		},
		
		/**
		 * Returns a random name
		 */ 
		randomName : function(){ return 'nch_group_' + Math.round( Math.random() * ( new Date() ).getTime() ) },
		
		/**
		 * Calculate hash for the given source
		 */
		getHash : function( m ){

			var s = m.href ? m.href : ( m.href = m.src ), h = 0, i, c, p = m.hash ? 1 : 0;

			if ( s === ndef || ( s + '' ).length == 0 ) return h;
			for ( i = 0; i < s.length; i++ ) {
				c = s.charCodeAt(i);
				h = (( h << 5 ) - h ) + c;
				h = h & h;
			}
			h = Math.abs( h );
			
			/**
			 * bug #5: Duplicate hash entries of the same image
			 * Add one until the hash isn't taken; deep linking still working
			 */
			if( routes[ defaults.hashpath + h ] !== ndef )
				while( routes[ defaults.hashpath + h ] !== ndef )
					h++;

			return h;
		
		},
		
		/**
		 * Returns the data attributes as name : value pairs. Pass an array of non-data attributtes 
		 * to include as a second argument.
		 */
		getDataProperties : function( object ){
	
			if( object.jquery ) object = object.get( 0 );
				
			var a = arguments, pass = a[ 1 ] ? a[ 1 ] : [], data = {}, v;

			for( var i = 0 ; i < object.attributes.length ; i++ ){
				var name = object.attributes[ i ].name;
				if( pass[ name ] || $.inArray( name, pass ) >= 0 || name.search( 'data-' ) == 0 )
					data[ pass[ name ] ? pass[ name ] : name.replace( 'data-', '' ) ] = ( ( v = object.getAttribute( name ) ) == parseInt ( v ) ) ? parseInt( v ) : v;
			}
			
			return data;
	
		},
		
		/**
		 * Applies the mask on the given canvas
		 */
		canvasMask : function( c, m ){
			
			if( ! _.hasCanvas ) return ;
			
			/**
			 * Shorthand for context
			 */
			var x, w, h;
			
			/**
			 * Save the properties
			 */
			this.$el = c;
			this.canvas = ( c = c.get( 0 ) );
			this.context = x = c.getContext( '2d' );
			this.mask = m;
			
			/**
			 * Resize according to the map size
			 */
			this.width = w = c.width = m.width;
			this.height = h = c.height = m.height;
			
			/**
			 * Set and read the mask data
			 */
			x.drawImage( m, 0, 0 );
			
			this.maskdata = ( function( d ){

				var r = [], p = 0;

				for( var i = 0; i < h; i ++ )
					for( var j = 0; j < w; j ++, p += 4 )
						r.push( d.data[ p ] );

				return r;
			
			})( x.getImageData( 0, 0, w, h ) );	
			
			x.clearRect( 0, 0, w, h );
			
			/**
			 * Mask method
			 */ 
			this.mask = function( ){
				
				/**
				 * Iterate and apply the map
				 */
				var a = this.maskdata, n = a.length * 4, l, i = 0, p = 0, d = x.getImageData( 0, 0, w, h ), g;
				
				while( i < n ){
					d.data[ i + 3 ] *= a[ i / 4 ] / 255;
					i += 4;			
				}
				
				/**
				 * Apply the image data
				 */
				x.putImageData( d, 0, 0 );
				
			}
			
		},
		
		/**
		 * Convert hexColor to RGB array
		 */
		hexToRGB : function( s ){
			
			var t = s.replace( '#', '' ), c = t.match( /.{1,1}/g );
			if( t.length / 3 < 2 ) t = c[ 0 ] + c[ 0 ] + c[ 1 ] + c[ 1 ] + c[ 2 ] + c[ 2 ];
			
			t = t.match( /.{1,2}/g );
			for( var i = 0; i < 3; i ++ ) t[ i ] = parseInt( t[ i ], 16 );
			return t;
	
		},
		
		/**
		 * bug #8
		 * Catch Firefox bug, drawImage gives NS_ERROR_NOT_AVAILABLE
		 *
		 * https://bugzilla.mozilla.org/show_bug.cgi?id=879717
		 */
		drawImageOnto: function( context, img, x, y, w, h, fn ){
			
			var ns = this, a = arguments;
			
			try {
				context.drawImage( img, x, y, w, h );
			} catch( e ){
				window.setTimeout( function(){ utils.drawImageOnto.apply( ns, a ) }, 0 );
				return ;
			}
			
			fn();
			
		},
		
		/**
		 * Gets the most saturated color in the given image
		 */
		getMainColor: function( img, fn ){
			
			var c = document.createElement( 'canvas' ), x = c.getContext( '2d' ), d, p = 0, s, t, mx = 0, w = c.width = 200, h = c.height = 200, l = [ 0, 0, 0 ], rt = utils.hexToRGB( _.current.opts.backlight );
			if( !( c.getContext && x ) ) return fn( rt );
			
			utils.drawImageOnto( x, img, 0, 0, 200, 200, function(){
				
				try {
			
					d = x.getImageData( 0, 0, w, h );
				
				} catch( e ){ return fn( rt ) }
				
				for( var i = 0; i < h; i ++ )
					for( var j = 0; j < w; j ++ ){
						s = ( d.data[ p ] + d.data[ p + 1 ] + d.data[ p + 2 ] ) / 3;
						t = Math.abs( s - d.data[ p ] ) + Math.abs( s - d.data[ p + 1 ] ) + Math.abs( s - d.data[ p + 1 ] );
						if( t > mx ){
							mx = t;
							l = [ d.data[ p ], d.data[ p + 1 ], d.data[ p + 2 ] ];
						}
						p += 4;
					}

				fn( l );
			
			});	
		
		}
	
	};
	
	/**
	 * Plugin declaration
	 */
	$.fn.nchlightbox = function( method ) {
		
		/**
		 * Method calling logic
		 */
		if ( methods[ method ] ) {
			return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else {
			return methods.init.apply( this, arguments );
		}

	};
	
	/**
	 * Use the reccomended method of changing options
	 */
	$.fn.nchlightbox.defaults = defaults;
	
	/**
	 * Initialize on DOMReady
	 */
	$( document ).ready( function(){
		
		$( '.nch-hide-if-javascript' ).hide();
		
		/**
		 * Save a reference to the body
		 */
		_.b = $( 'body' );
		_.w = $( window ).resize( utils.updateLayout );
		_.doc = $( document.documentElement );
		
		/**
		 * Listen for hashchanges
		 */
		utils.hashChange();
		
		/**
		 * Checks if device has touch interface via CSS
		 */
		var touch_test = $( '<div id="nchlb_touch_device"></div>' );
		_.b.append( touch_test );
		if( ( touch_test.position())[ 'top' ] < 0 ) _.isTouchDevice = true;
		touch_test.remove();
		
		/**
		 * Check if device has touch interface via the DOM properties
		 */
		try{
			if(( 'ontouchstart' in window ) || window.DocumentTouch && document instanceof DocumentTouch)
				_.isTouchDevice = true;
		
		/**
		 * For old browsers which don't support instanceof
		 */
		} catch( e ){}
		
		/**
		 * Don't hide the photomenu on touch devices
		 */
		if( _.isTouchDevice ) _.b.addClass( 'nch-lb-photo-menu-visible' );
		
		/**
		 * Detect and use a PNGfix for Android Stock Browser
		 * bug #4: Canvas artifacts when altering the alpha channel
		 * https://code.google.com/p/android/issues/detail?id=17565
		 */
		var ua;		
		_.asb = ( ( ua = navigator.userAgent.toLowerCase() ).search( 'android' ) > 0 && ua.search( 'mobile safari' ) > 0 &&	ua.search( 'linux' ) > 0 && ua.search( 'chrome' ) < 0 );

		
		/**
		 * Get mask URL and load the image if canvases are supported
		 */		
		var c = document.createElement( 'canvas' ), e = _.root = $( '<div class="nch-lb-mask"></div>' ).appendTo( _.b );
		
		if( _.hasCanvas = !!( c.getContext && c.getContext( '2d' ) ) ){
			
			mask = new Image();
			mask.onload = utils.masks;
			mask.src = utils.getImageURL( e );

			$( _.tcanvas = document.createElement( 'canvas' ) ).addClass( 'nch-lb-testcanvas' ).appendTo( _.b );
			
		} else utils.masks();
		
		/**
		 * Test if browser has fullscreen support 
		 */
		_.canFS = utils.fs.has();
		utils.fs.on = false;
		
		/**
		 * Add keyboard support
		 */
		_.w.keyup( utils.keyboard );
		
		/**
		 * Detect scrollbar width
		 */
		var sbar = $( '<div class="nch-lb-scrollbars"></div>' ).appendTo( _.b ), cw = sbar.get( 0 ).clientWidth, ow = sbar.get( 0 ).offsetWidth;
		if( cw !== ndef && ow !== ndef && ow == cw ) _.scrollbar = false;
		sbar.remove();
		
		/**
		 * Parse the elements
		 */
		$( '.nch-lightbox' ).nchlightbox( );
		
	});
	
	
	

})( jQuery );

/**
 * Nacho CSS3 Transitions
 * 
 * @description: Easily animate objects using CSS3
 * @version: 1.00
 * @author: dcristi
 */

;( function( $, w, d, ndef ){
	
	/**
	 * Store the right properties and units
	 */
	var _ = { }, props = { }, css3 = { }, units = {
		
		rotate : 'deg',
		rotateX : 'deg',
		rotateY : 'deg',
		skewX : 'deg',
		skewY : 'deg',
		perspective : 'px',
		scale : '',
		translateX : 'px',
		translateY : 'px',
		translateZ : 'px'
		
	};
	
	/**
	 * Convert CSS properties to camelCase
	 */
	function toCamelCase( property ){
		
		var words = property.split( '-' );
		
		for( var i = 1 ; i < words.length; i ++ )
			words[ i ] = words[ i ].substr( 0, 1 ).toUpperCase() + words[ i ].substr( 1 );
		
		return words.join( '' );
		
	}
	
	/**
	 * Get the relevant property
	 */
	function hasProperty( property, prefixes ){
		
		var rule = property, pre = prefixes || [ 'ms', 'O', 'Moz', 'Webkit', 'Khtml' ], camel = ( property = toCamelCase( rule ) ).substr( 0, 1 ).toUpperCase() + property.substr( 1 ), all, el = d.documentElement;

		/**
		 * Unprefixed version
		 */
		if( el.style[ property ] !== ndef ) {
			css3[ rule ] = rule; 
			return property;
		}
		
		all = ( pre.join( camel + '/' ) + camel ).split( '/' );
		
		for( var i in all ) 
			if( el.style[ all[ i ] ] !== ndef ){
				css3[ rule ] = '-' + pre[ i ].toLowerCase() + '-' + rule;
				return all[ i ];
			}
		return false;
	
	}
	
	
	/**
	 * Get the right properties
	 */
	( function( ){
		
		var p = arguments;
		
		for( var i = 0 ; i < p.length ; i ++ )
			props[ p[ i ] ] = hasProperty( p[ i ] );

	})( 'transform', 'perspective', 'transition', 'transform-origin' );
	
	/**
	 * Apply CSS3 transform to the object 
	 */
	_.transform = function( name, value ){
		
		/**
		 * Normalize input
		 */
		var rules = ( value === ndef ) ? name : ( function( o ){ o[ name ] = value; return o })({}), tr = [];
		
		/**
		 * Check if property can be used
		 */
		if( props[ 'transform' ] === false ) return ;
		
		for( var prop in rules ){
			
			/**
			 * Add unit if missing
			 */
			if( units[ prop ] !== ndef && ( rules[ prop ] + '' ).search( units[ prop ] ) < 0 )
				rules[ prop ] += units[ prop ];
				
			tr.push( prop + '(' + rules[ prop ] + ')' );
			
		}
		
		/**
		 * Apply the style
		 */
		this.style[ props[ 'transform' ] ] = tr.join( ' ' ); 
		
	}
	
	/**
	 * Set the transition property
	 */
	_.transition = function( unit ){
		
		if( this.style.setProperty === ndef ) this.style[ props[ 'transition' ] ] = unit;
		else this.style.setProperty( css3[ 'transition' ], unit );
	
	};
	
	/**
	 * Set the transform-origin property
	 */
	_.transformOrigin = function( unit ){
		
		if( this.style.setProperty === ndef ) this.style[ props[ 'transform-origin' ] ] = unit;
		else this.style.setProperty( css3[ 'transform-origin' ], unit );
	
	};
	
	/**
	 * Apply perspective
	 */
	_.perspective = function( unit ){
	
		if( props[ 'perspective' ] === false ) return ;
		
		if( ( unit + '' ).search( units[ 'perspective' ] ) < 0 )
			unit += units[ 'perspective' ];
			
		if( this.style.setProperty === ndef ) this.style[ props[ 'perspective' ] ] = unit;
		else this.style.setProperty( css3[ 'perspective' ], unit );

	}
	
	/**
	 * Animate the properties
	 */
	_.animate = function( props, delay, complete ){
		
		var ns = this, delay = delay || 400, unit = [ css3[ 'transform' ] ].join( ',' ) + ' ' + ( delay / 1000 ) + 's ' + 'ease-in'; 
		
		_.transition.call( this, unit );
		
		_.transform.call( this, props );
		
		w.setTimeout( function(){
			
			_.transition.call( ns, 'none' );

			if( complete !== ndef ) complete();
			
		}, delay );

	}
	
	/**
	 * External interface
	 */
	$.fn.nchlightbox( 'access', 'css3', function( dom ){
	
		return new ( function( object ){
			
			var ns = this;
			
			/**
			 * Strip out jQuery
			 */
			this.el = ( object.jquery === ndef ) ? object : ( this.$el = object ).get( 0 );
			
			/**
			 * Make the methods available
			 * Known to cause tiny memory leaks
			 */
			for( var i in _ )
				this[ i ] = ( function( method ){					
					return function(){ _[ method ].apply( ns.el, arguments ); }
				})( i );

		})( dom );
		
	});
	
})( jQuery, window, document );


/**
 * Lightbox effects
 */
(function( $, ndef ){
	
	/**
	 * Property shortcuts
	 */
	var p = 'perspective', sx='skewX', sy = 'skewY', r = 'rotate', rx = 'rotateX', ry = 'rotateY', tx = 'translateX', ty = 'translateY', tz = 'translateZ', o = 'opacity', md = '50% 50%', dl = $.fn.nchlightbox.defaults, s = 'scale';	
	
	/**
	 * Minifies effect
	 */
	function minfx( delay, propfn, xfactor ){
		
		return function( css3, stage, animate, xaxis ){
			
			if( xaxis !== ndef ) return ( xfactor == 1 ) ? ndef : xfactor * xaxis;
			
			var d = propfn( stage, Math.abs( stage ) ), args = [ d[ 0 ] ];
			
			css3.transformOrigin( d[ 2 ] || md );
			
			if( animate ) args.push( delay.fxspeed );
			
			if( d[ 0 ] !== ndef ) css3[ animate ? 'animate' : 'transform' ].apply( {}, args );
			
			if( d[ 1 ] !== ndef ) {
			
				args[ 0 ] = d[ 1 ];
				$.fn[ animate ? 'animate' : 'css' ].apply( css3.$el.stop(), args );
				
			}
			
		}
		
	}
	
	
	/**
	 * Register, so the plugin can use it 
	 */
	$.fn.nchlightbox( 'fx', {
		
		/**
		 * Default effect
		 */
		swipe: function(){},
		
		/**
		 * Fades as it swipes
		 */
		fade: minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ o ] = 1 - abs;
			
			return [ ndef, a ];
		
		}, 1 ),
		
		/**
		 * The following effect scales down the image using inbuilt css3 functions and fades it away.
		 */
		scale: minfx( dl, function( stage, abs ){
		
			var a = {};
			a[ s ] = 1 - ( .6 * abs );
			
			return [ a ];
		
		}, 1 ),
		
		slideUp : minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ ty ] = 900 * stage;
			return [ a ];
		
		}, 0 ),
		
		slideDown : minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ ty ] = - 900 * stage;
			return [ a ];
		
		}, 0 ),
		
		
		flip : minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ p ] = 1000;
			a[ ry ] = 90 * stage;
			
			return [ a ];
			
		}, 0 ),
		
		skew : minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ p ] = 1000;
			a[ sx ] = 30 * stage;
			
			return [ a ];
		
		}, 1 ),
		
		bounceDown: minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ p ] = 100;
			a[ ty ] = 1000 * abs;
			
			return [ a ];
		
		}, 1 ),
		
		bounceUp: minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ p ] = 100;
			a[ ty ] = - 1000 * abs;
			
			return [ a ];
		
		}, 1 ),
		
		hangLeft: minfx( dl, function( stage ){
			
			var a = {};
			a[ r ] = - 179 * stage;
			
			return [ a, ndef, '0% 0%' ];
			
		}, 0 ),
		
		hangRight: minfx( dl, function( stage ){
			
			var a = {};
			a[ r ] = - 179 * stage;
			
			return [ a, ndef, '100% 0%' ];
			
		}, 0 ),
			
		zoomIn: minfx( dl, function( stage, abs ){
			
			var a = {}, b = {};
			a[ p ] = 800;
			a[ tz ] = 800 * abs;
			a[ r ] = 45 * stage;
			b[ o ] = 1 - abs;
			
			return [ a, b ];
	
		}, 0 ),		
		
		
		breakIn: minfx( dl, function( stage ){
			
			var a = {};
			a[ r ] = 45 * stage;
			
			return [ a ];
		
		}, 1 ),
		
		rotateIn: minfx( dl, function( stage, abs ){
		
			var a = {};
			a[ p ] = 1000;
			a[ ry ] = 90 * stage,
			a[ s ] = 1 - ( .3 * abs );
			
			return [ a ];
			
		}, 1 ),
		
		rotateOut: minfx( dl, function( stage, abs ){
		
			var a = {};
			a[ p ] = 1000;
			a[ ry ] = - 90 * stage,
			a[ s ] = 1 - ( .3 * abs );
			
			return [ a ];
			
		}, 1 ),		
		
		cicleDown: minfx( dl, function( stage, abs ){
			
			var a = {}, b = {};
			a[ p ] = 1200;
			a[ rx ] = -90 * stage,
			a[ ty ] = 200 * abs;
			b[ o ] = 1 - abs;			
			
			return [ a, b, '50% 100%' ]
			
		}, 0 ),
		
		
		cicleUp: minfx( dl, function( stage, abs ){
			
			var a = {}, b = {};
			a[ p ] = 1200;
			a[ rx ] = - 90 * stage,
			a[ ty ] = - 200 * abs;
			b[ o ] = 1 - abs;			
			
			return [ a, b, '50% 1%' ]
			
		}, 0 ),
		
		
		throwIn: minfx( dl, function( stage, abs ){
			
			var a = {}, b = {};
			a[ p ] = 800;
			a[ s ] = 1 - ( .6 * abs );
			a[ r ] = 180 * stage;
			b[ o ] = 1 - abs;
			
			return [ a, b ]
		
		}, .3 ),
		
		fall: minfx( dl, function( stage, abs ){
		
			var a = {}, b = {};
			a[ p ] = 1800;
			a[ rx ] = -90 * abs;
			a[ r ] = 90 * stage;
			a[ tz ] = - 400 * stage;
			
			b[ o ] = Math.pow( 1 - abs, .25 );
			
			return [ a, b, md ];
			
		}, 0 ),
		
		
		jump: minfx( dl, function( stage, abs ){
			
			var a = {};
			a[ p ] = 1500;
			a[ s ] = 1 - ( .999 * abs );
			a[ ty ] = 300 * abs;
			a[ rx ] = 100 * abs;
			a[ tz ] = 1000 * abs;
			
			return [ a ];
		
		}, 0 )		
		
	});
	
})(jQuery);
 
 
/**
 * Social sharing plugin
 */
( function( $ ){
	
	var api = { 
		
		fb: {
			has: 'FB',
			api: function(){ return FB },
			parse: function( a, c ){ a.XFBML.parse( c ) },
			id: 'facebook-jssdk',
			src: '//connect.facebook.net/en_US/all.js',
			create: '<div class="nchlb_like_container"><iframe class="fb-like" src="//www.facebook.com/plugins/like.php?layout=standard&amp;action=like&amp;show_faces=false&amp;share=false&amp;height=20&amp;href={url}" scrolling="no" frameborder="0" style="border:none; overflow:hidden; height:20px;" allowTransparency="true"></iframe></div>'
		},
		
		tw: {
			has: 'twttr',
			api: function(){ return twttr },
			parse: function( a, c ){ a.widgets.load( c ) },
			id: 'twitter-wjs', 
			src: '//platform.twitter.com/widgets.js',
			create: '<a href="https://twitter.com/share" class="twitter-share-button" data-url="{url}" data-text="{title}" data-count="none">Tweet</a>'
		},
		
		gp: {
			has: function(){
				if( typeof gapi === 'undefined' || typeof gapi.plusone == 'undefined' ) return false;
				return true;
			},
			api: function(){ return gapi.plusone },
			parse: function( a, c ){ a.go( c ) },
			id: '', 
			src: '//apis.google.com/js/plusone.js',
			create: '<div class="g-plusone" data-size="medium" data-annotation="none" data-href="{url}"></div>'
		},
		
		pin: {
			has: function(){ 
				for( var i in window ) if( i.search( 'PIN_' ) == 0 ) return true; 
				return false; 
			},
			api: function(){
				for( var i in window ) if( i.search( 'PIN_' ) == 0 && window[ i ].f ) return window[ i ];
			},
			parse: function( a, c ){
			
				var l = $( c ).is( 'a' ) ? [ c ] : c.getElementsByTagName( 'a' ), t, p = a.f.render;
				for( var i = 0 ; i < l.length ; i ++ )
					if( typeof ( t = $( l[ i ] ).attr( 'data-pin-do' ) ) != 'undefined' )
						p[ t ]( l[ i ] );

			},
			id: '', 
			src: '//assets.pinterest.com/js/pinit.js',
			create: '<a href="//pinterest.com/pin/create/button/?url={url}&media={media}&description={title}" data-pin-do="buttonPin" data-pin-config="none"><img src="//assets.pinterest.com/images/pidgets/pin_it_button.png" /></a>'
		}
		
	};
	
	function compileURI( url, data ){
		
		var r = '', c = false, name = '';
		
		for( var i = 0 ; i < url.length ; i ++ )
			if( c ){			
				if( url.charAt( i ) == '}' ){
					if( data[ name ] ) r += data[ name ];
					c = false;
					name = '';
				} else { 
					name += url.charAt( i ); 
				}			
			}
			else if( url.charAt( i ) == '{' ) c = true;
			else r += url.charAt( i );
		
		return r;

	};
	
	function hasApi( c ){
	
		if( typeof c.has.charAt == 'undefined' ) return c.has();
		else if( typeof window[ c.has ] != 'undefined' ) return true;
		return false;
		
	};
	
	function loadApi( c ){
		
		var s = document.createElement( 'script' );
		s.async = true;
		s.id = c.id;
		s.src = c.src;
		
		b.append( s );
	
	};
	
	function getButtons( t, b, o ){
		
		var a, b = b.split( ',' ), s = '', p = [];
		
		for( var i = 0; i < b.length; i++ )
			if( p[ i ] = hasApi( a = api[ b[ i ] ] ) )
				s += compileURI( a.create, o );

		t.append( s );
		
		for( var i in b ) if( p[ i ] ) api[ b[ i ] ].parse( api[ b[ i ] ].api(), t.get( 0 ) );
	
	};
	
	var b;
	
	$( window ).load( function(){
		
		var c;
		b = $( 'body' );
		
		for( var i in api ) {
			c = api[ i ];
			if( ! hasApi( c ) ) loadApi( c );
		}
		
		/**
		 * Allow nchlightbox to access getButtons method
		 */
		$.fn.nchlightbox( 'access', 'shareButtons', getButtons );
		
	})

})( jQuery ); 


/**
 * Grid plugin
 */
( function ( $, w, ndef ){
	
	var utils = {
	
		grid: function( set, opts ){
			
			this.name = '';
			this.set = set;
			this.opts = $.extend( {}, $.fn.nchgrid.defaults, opts );
            this.images = [];
			this.items = [];
			this.cols = [];
			
			/**
			 * State properties
			 */
			this.width = 0;
			this.columns = 0;
			this.filters = [];

			/**
			 * Make sure a target exists
			 */
			if( ! opts.target ) this.opts.target = $( set.parent() );

		},
        
        column: function(){
            
            this.images = [];
            this.height = 0;
            this.width = 0;
            this.aspect = 0;
			this.less = false;

            this.addImage = function( img ){

                this.images.push( img );
                this.aspect += img.aspect;
            
            }
        
        },
		
        getColumns: function( width, grid ){
            
            var i = 0;
            
            while( grid[ i ] < width ) i++;
            
            return ( i == grid.length ) ? i : i + 1;
        
        },
        
		/**
		 * Solves height conflicts, where one column needs to be delta pixels taller
		 */
		resolveDeltaHeight: function( width, delta, aspect1, aspect2 ){
		
			return ( width + ( delta * aspect2 ) ) / ( aspect1 + aspect2 );
		
		},
		
		/**
		 * Spreads the images across columns
		 */
		spreadImages: function( grid, columns ){
			
			var img = grid.images, n = img.length;
			
			/**
			 * Keep the order of images
			 */
			if( grid.opts.order ) {
				
				for( var i = 0 ; i < n ; i ++ )
					columns[ i % grid.columns ].addImage( img[ i ] );
				
			/**
			 * Try to fit the images as best as possible
			 */ 
			} else {
				
				var line, all = img.length, index = 0, cols = grid.columns, col = [];
				
				for( var i = 0 ; i < cols ; i ++ ) 
					col.push({ index: col.length, aspect: 0 });
				
				while( index < all ){
					
					line = [];
					
					for( var i = 0 ; i < cols ; i ++ )
						if( img[ index + i ] != ndef )
							line.push({ 
								aspect: 1 / img[ index + i ].aspect,
								index: index + i
							});
					
					line.sort( function( a, b ){ return a.aspect > b.aspect } );					
					col.sort( function( a, b ){ return a.aspect < b.aspect } );
					
					for( var i = 0 ; i < line.length ; i ++ ){
						columns[ col[ i ].index ].addImage( img[ line[ i ].index ] );
						col[ i ].aspect += line[ i ].aspect;
					}
						
					index += cols;
				
				}	
				
			}
		
		},
		
		renderGrid: function( grid ){
			
			var fn = function(){ utils.updateGrid( grid ) };

			$( window ).resize( fn );
			
			fn();
		
		},
		
		/**
		 * Makes up the DOM content for the grid
		 */
		updateGrid: function( grid ){
			
			var o = grid.opts, 
				set = grid.set, 
				img = grid.images, 
				container = o.target, 
				sizes = [], 
				columns = grid.cols,
				width = o.target.width();
			
			/**
			 * Do nothing if the container has the same size
			 */
			if( grid.width == width ) return ;
			
			grid.columns = utils.getColumns( grid.width = width, o.grid );
			
			/**
			 * Spread images if the number of columns changed
			 */
			if( grid.columns != columns.length ){
            	
				columns = [];

				for( var i = 0; i < grid.columns ; i ++ )
					columns[ i ] = new utils.column();
				
				utils.spreadImages( grid, columns );
				
			}
			
			var availableSpace = grid.width - ( ( columns.length - 1 ) * o.margin ), 
				leastElements = Math.floor( img.length / grid.columns ),
				aspect1 = 0,
				aspect2 = 0;
            
			/**
			 * Compute the boxes aspects
			 */
			for( var i = 0 ; i < grid.columns ; i ++ )
				if( columns[ i ].less = columns[ i ].images.length == leastElements ) aspect1 += 1 / columns[ i ].aspect;
				else aspect2 += 1 / columns[ i ].aspect;
			
			/**
			 * Calculate the grid height
			 */
			var height = utils.resolveDeltaHeight( availableSpace, o.margin, aspect1, aspect2 ), images, xAxis = 0, yAxis = 0, columnWidth, c, image;
			
			/**
			 * Render those columns
			 */
			for( var i = 0; i < columns.length; i++ ){
				
				c = columns[ i ];
				all = c.images;
				
				columnWidth = 1 / c.aspect * ( height - ( c.less ? 0 : o.margin ) );
				yAxis = 0;
				
				for( var j = 0; j < all.length ; j++ ){
				
					image = $( grid.items[ all[ j ].index ] ).css({
					
						position: 'absolute',
						left: xAxis,
						top: yAxis,
						width: columnWidth,
						height: columnWidth * all[ j ].aspect,
						display: 'block'
						
					}).addClass( 'nchgrid-tile' );
					
					yAxis += columnWidth * all[ j ].aspect + o.margin;
				
				}
				
				xAxis += columnWidth + o.margin;
			
			}
			
			/**
			 * Set the height
			 */
			container.height( yAxis - o.margin );
			
			/**
			 * Make sure has the right positioning
			 */
			if( container.css( 'position' ) == 'static' ) container.css( 'position', 'relative' );
			
	
		},
		
		/**
		 * Trigger click on the image
		 */
		triggerClick: function( e ){
			
			if( $( e.target ).is( 'img' ) ) return ;
			
			$( this ).find( 'img' ).click();
		
		},
		
		/**
		 * Loading tiles function
		 */
		loadTiles: function( fn ){
			
            var ns = this, loaded = 0;
			
			function setWidth( index, width, height ){
                
				var d, c;
				
                ns.images[ index ] = {

                    width: width,
                    height: height,
                    aspect: height / width,
                    src: ns.set[ index ].src,
					index: index,
					caption: c = ns.set[ index ].title

                };				
				
				ns.items[ index ] = ( d = $( '<div class="nchgrid-item"></div>' ).insertAfter( ns.set[ index ] ).append( ns.set[ index ] ) ).get( 0 );
				
				if( ns.opts.captions && ( c + '' ).length ){
					d.append( '<div class="nchgrid-caption"></div><div class="nchgrid-caption-text">' + c + '</div>' ).click( utils.triggerClick );
				}
				
                if( loaded++ == ns.set.length - 1 ) utils.renderGrid( ns );

            }
            
			this.set.each( function( i, o ){
				
				var m = new Image();
				m.onload = function(){
                    
					setWidth( i, this.width, this.height );
					o.style.display = 'block';
					
				};
				m.src = this.src;				
				o.style.display = 'none';
			
			});
		
		}
		
	},
	
	methods = {
	
		init : function( opts ){
			
			var set = this;
			
			/**
			 * Dynamic creation
			 */
			if( ! this.length ) {
				
				var a = arguments, list = opts, c, img = [];
				
				opts = $.extend( {}, $.fn.nchgrid.defaults, ( a.length == 2 ) ? a[ 1 ] : {} );
				
				for( var i = 0 ; i < list.length ; i ++ ){
					c = new Image();
					c.src = list[ i ];
					
					img.push( c );
				}
				
				set = this.add( img ).appendTo( opts.target );

			}
			
			utils.loadTiles.call( new utils.grid( set, $.extend( {}, $.fn.nchgrid.defaults, opts || {} ) ) );
			
			return set;
			
		}
	
	};
	
	$.fn.nchgrid = function( method ){
		
		/**
		 * Method calling logic
		 */
		if ( methods[ method ] ) {
			return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else {
			return methods.init.apply( this, arguments );
		}
	
	};
	
	$.fn.nchgrid.defaults = {
		
		margin: 4,
		grid: [ 240, 480, 720, 960, 1240 ],
		captions: false,
		order: false,
		target: false
		
	};
	

})( jQuery, window );


/**
 * Pinch zoom module 
 */
 
( function( $, w, d, ndef ){
	
	// reference css3 library
	var access = $.fn.nchlightbox( 'access' ), css3 = access.css3;
	
	// touch support boolean value
	var hasTouch = false, touchHandler = $( w ).hammer();
	
	// handle the test event
	function testTouch( e ){ 

		// doesn't have a touch, so use the simpler mouse interface
		if( ( e.gesture.srcEvent.type + '' ).split( 'touch' ).length == 2 ) hasTouch = true; 
		
		// remove event listener
		touchHandler.off( 'touch', testTouch );

	}
	
	// wait for a touch event to happen
	touchHandler.on( 'touch', testTouch ); 
	
	// pinchzoom class constructor
	function pinch( $el, width, height ){
		
		var scale = 1, cx, cy, tx = 0, ty = 0, gesture = false, cnt, _ = this;
		
		// create the base layout
		this._el = css3( $el );
		this.$el = $el.css({ display: 'block' });		
		
		this.container = cnt = $( '<div></div>' ).insertAfter( $el ).append( $el );
		this._container = cnt.hammer({ prevent_default: true });
		
		// read the target's dimensions
		this.width = $el.get( 0 ).width || $el.width();
		this.height = $el.get( 0 ).height || $el.height();
		
		// state properties
		this.scale = 1;
		this.centerX = 0.5;
		this.centerY = 0.5;
		this.translateX = 0;
		this.translateY = 0;
		this.transform = _.transform = identityMatrix();
		
		// prepare the object
		this._el.transformOrigin( '0 0' );
		this.container.css({ 
			width: width || this.width,
			height: height || this.height,
			overflow: hasTouch ? 'hidden' : 'auto'
		}); 
		
		var x, y, sx, sy, p, px, py, tx = 0, ty = 0, dx = 0, mx = 0, my = 0, dy = 0, rx = 0, ry = 0, tr, ts = false, ds = false;
		
		// updates the container dimensions
		function updateContainer(){
			
			_.cwidth = _.container.width();
			_.cheight = _.container.height();
			
		}
		
		// updates the dimensions
		updateContainer();
		
		// creates a 3x3 identity/scaling matrix, actually a vector
		function identityMatrix( i ){
			
			i = ( i === ndef ) ? 1 : i;
			
			// return an object so it can be referenced
			return { e: [ i, 0, 0, 0, 0, i, 0, 0, 0, 0, i, 0, 0, 0, 0, 1 ] };
		
		}

		// converts the matrix object to a string to be used in css3 transforms
		function toValue( m ){ return m.e.join( ', ' ) }
		
		// calculates scrolling limits
		function limits( s ){
			
			var wx = _.width * s - _.cwidth,
				wy = _.height * s - _.cheight;
				
			mx = - Math.abs( ( wx < 0 ) ? 0 : wx );
			my = - Math.abs( ( wy < 0 ) ? 0 : wy );
			
		} 
		
		// start function
		this.transformStart = function( e ){
			
			if( ds ) { 
				ds = false;
				_.dragEnd( e );
			}
			
			updateContainer();
			ts = true;
			
			// read event position
			x = e.gesture.center.pageX;
			y = e.gesture.center.pageY;
			
			// read scrollX and scrollY
			sx = cnt.scrollLeft();
			sy = cnt.scrollTop();
			
			// get element position inside the page
			p = cnt.offset();
			px = p.left;
			py = p.top;
			
			// calculate position on the image
			_.centerX = cx = ( x - px - tx - rx ) / _.width / _.scale; cx = ( cx < 0 ) ? 0 : ( ( cx > 1 ) ? 1 : cx );
			_.centerY = cy = ( y - py - ty - ry ) / _.height / _.scale; cy = ( cy < 0 ) ? 0 : ( ( cy > 1 ) ? 1 : cy );

		}
		
		// drag handler
		this.drag = function( e ){
			
			if( ts ) return ;
			
			gesture = e.gesture;
			
			rx = gesture.deltaX + tx + dx;
			ry = gesture.deltaY + ty + dy;
			
			// calculate translation limits
			limits( scale );

			// apply transformation
			var tm = identityMatrix( scale );
			tm.e[ 12 ] = rx = ( rx < 0 ) ? ( ( rx > mx ) ? rx : mx ) : 0;
			tm.e[ 13 ] = ry = ( ry < 0 ) ? ( ( ry > my ) ? ry : my ) : 0;
			
			// apply transformation
			_._el.transform( 'matrix3d', toValue( tr = tm ) );
		
		}
		
		// pinch handler
		this.pinch = function( e ){
			
			ts = true;
			gesture = e.gesture;
			
			scale = _.scale * gesture.scale;
			
			// limit scaling
			if( scale < 1 ) scale = 1;
			if( scale > 4 ) scale = 4;

			// limit the movement
			limits( scale );
			
			dx = ( _.scale - scale ) * _.width * _.centerX + tx + rx;
			dy = ( _.scale - scale ) * _.height * _.centerY + ty + rx;
			
			// apply transformation
			var tm = identityMatrix( scale );
			tm.e[ 12 ] = dx = ( dx < 0 ) ? ( ( dx > mx ) ? dx : mx ) : 0;
			tm.e[ 13 ] = dy = ( dy < 0 ) ? ( ( dy > my ) ? dy : my ) : 0;
			
			// apply transformation
			_._el.transform( 'matrix3d', toValue( tr = tm ) );

		}
		
		this.transformEnd = function( e ){
		
			_.scale = scale;
			_.transform = tr;
	
			ts = true;
			
			tx = dx;
			ty = dy;

			rx = ry = dx = dy = 0;

		}
		
		this.dragEnd = function( e ){
			
			ds = false;
						
			if( ts ) {
				ts = false;
				return ;
			}

			_.transform = tr;

			tx = rx;
			ty = ry;
			
			dx = dy = rx = ry = 0;
			
		}
		
		this.dragStart = function( e ){
			
			updateContainer();
	
			if( ts ) return ;
			ts = false;
			ds = true;
			
		}
		
		// bind functions to their events
		if( hasTouch )
			this._container
				.on( 'transformstart', this.transformStart )
				.on( 'transform', this.pinch )
				.on( 'transformend', this.transformEnd )
				.on( 'dragstart', this.dragStart )
				.on( 'drag', this.drag )
				.on( 'dragend', this.dragEnd );

	}
	
	// pass on the arguments
	$.fn.nchlightbox( 'access', 'pinch', function( width, height ){
		
		var set;
		
		$( this ).each( function( i, o ){
			
			var k;
			
			// keep a data reference, just in case
			o = $( o );
			o.data( 'nch-pinchzoom', k = new pinch( o, width, height ) );
			
			if( set === ndef ) set = $( k.container );
			else set.add( k.container );
			
		});
		
		return set;
	
	});
	
	
	
})( jQuery, window, document );